---
title: 重载 Overload
date: 2025-10-30
series: Java
category: Note
---




# 重载 OverLoad

Java中允许同一个类中，多个同名方法的存在，但要求形参列表不一致

比如sout out是printStream类型

如无重载

printlnt

printChar

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// Overload of Method
		//
		System.out.println(100);
		System.out.println("100");

	}
}

class Tower {

}

```



## 方法重载快速入门



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// Overload of Method
		//
		// System.out.println(100);
		// System.out.println("100");

		// My calculator方法的调用
		// 可以根据传入类型自动匹配方法
		MyCalculator mc = new MyCalculator();
		System.out.println(mc.calculate(1, 2, 3));
	}
}

class MyCalculator {
	// 两个整数的和
	public int calculate(int n1, int n2) {
		return n1 + n2;
	}

	// 一个整数，一个double的和
	public double calculate(int n1, double n2) {
		return n1 + n2;
	}

	// 一个double，一个int的和
	public double calculate(double n2, int n1) {
		return n2 + n1;
	}

	// 三个int的和
	public int calculate(int n1, int n2, int n3) {
		System.out.println("三个int的和被调用");
		return n1 + n2 + n3;
	}

}

```



## 方法重载的注意细节



**方法重载就是同名不同参**

1. 方法名一定要相同
2. 形参列表必须不同
   1. 形参顺序不同
3. 返回类型无要求



## 方法重载的使用

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// Overload of Method
		//
		// System.out.println(100);
		// System.out.println("100");

		// My calculator方法的调用
		// 可以根据传入类型自动匹配方法
		Methods m = new Methods();
		m.m(2);
		m.m(3, 2);
		m.m('a');
	}
}

class Methods {

	public void m(int n) {
		System.out.println(n * n);
	}

	public void m(int n1, int n2) {
		System.out.println(n1 * n2);
	}

	public void m(char char1) {
		System.out.println(char1);
	}

}

```



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// Overload of Method
		//
		// System.out.println(100);
		// System.out.println("100");

		// My calculator方法的调用
		// 可以根据传入类型自动匹配方法
		Methods m = new Methods();
		System.out.println(m.max(2, 3));
		System.out.println(m.max(2.1, 3.2));
		// 在方法的重载中优先使用匹配的数据类型，然后选择提升精度的类型。
		System.out.println(m.max(2.6, 3, 4.1));
		System.out.println(m.max(2.6, 3, 4));
	}
}

class Methods {

	public int max(int n1, int n2) {
		return n1 > n2 ? n1 : n2;
	}

	public double max(double n1, double n2) {

		return n1 > n2 ? n1 : n2;
	}

	public double max(double n1, double n2, double n3) {

		double max = n1 > n2 ? n1 : n2;
		return max > n3 ? max : n3;
	}

	public double max(double n3, double n4, int n5) {

		double max = n3 > n4 ? n3 : n4;
		return max > n5 ? max : n5;
	}

}

```





# 可变参数



Java允许将同一个类中多个同名同功能但参数个数不同的方法封装成一个方法，就可以通过可变参数实现



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Methods methods = new Methods();
		methods.sum(1, 5, 9, 6, 4, 1, 3);
		System.out.println(methods.sum(1, 5, 9, 6, 4, 1, 3));
	}
}

class Methods {

	// int...表示可以接收多个参数个数，类型是int，即可以接收多个int(0-n)
	// 使用可变参数时，可以当作数组来使用，即sums可以当作数组。
	// 遍历sums求和即可
	public int sum(int... sums) {
		System.out.println("数组sums的个数为：" + sums.length);
		int res = 0;
		for (int i = 0; i < sums.length; i++) {
			res += sums[i];
		}
		return res;
	}
}

```





## 可变参数的注意细节

1. 可变参数的实参可以为0个或任意多个。

2. 可变参数的实参可以为数组

3. 可变参数的本质就是数组

4. 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后

   1. ```java
      	//可变参数必须在形参列表的最后
      	//错误示范：
      	//public int sum(int n1,int... sums,int n3) {
      	// 	System.out.println("数组sums的个数为：" + sums.length);
      	// 	int res = 0;
      	// 	for (int i = 0; i < sums.length; i++) {
      	// 		res += sums[i];
      	// 	}
      	// 	return res;
      	// }
      	
      ```

      

5. 一个形参列表中只能出现一个可变参数



**练习**

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Methods methods = new Methods();

		System.out.println(methods.list("Jack", 1, 2, 3, 4, 5));

	}
}

class Methods {

	// int...表示可以接收多个参数个数，类型是int，即可以接收多个int(0-n)
	// 使用可变参数时，可以当作数组来使用，即sums可以当作数组。
	// 遍历sums求和即可
	public String list(String n1, double... sums) {

		int res = 0;
		for (int i = 0; i < sums.length; i++) {

			res += sums[i];
		}
		return n1 + "的总分是" + res;

	}

}

```





# 作用域



1. 在Java编程中，主要的变量就是属性（成员变量），和局部变量

2. 局部变量一般是指在成员方法中定义的变量

   1. ```java
      public class MainNew {
      	public static void main(String[] args) {
      		System.out.println(" ");
      		System.out.println(" ");
      
      		Methods methods = new Methods();
      
      		System.out.println(methods.list("Jack", 1, 2, 3, 4, 5));
      
      	}
      }
      
      class Methods {
      
      	// int...表示可以接收多个参数个数，类型是int，即可以接收多个int(0-n)
      	// 使用可变参数时，可以当作数组来使用，即sums可以当作数组。
      	// 遍历sums求和即可
      	public String list(String n1, double... sums) {
      
      		int res = 0;
      		for (int i = 0; i < sums.length; i++) {
      
      			res += sums[i];
      		}
      		return n1 + "的总分是" + res;
      
      	}
      
      }
      
      class Cat{
          //全局变量就是属性
          //属性在定义时，可以直接赋值
          int age = 10;
      	public void cry(){
      
      		int n = 10;
      		String name ="jack";
              System.out.println("在cry中使用属性age："+age);
      	}
          public void eat(){
              System.out.println("age="+age);
      		//不在作用域内。
      		//System.out.println("在eat中使用cry"+name);
          }
      }
      ```

   2. n和name就是局部变量

   3. n和name 的作用域在cry方法中

3. 全局变量/属性 可以不赋值，直接使用，局部变量必须在赋值之后才能使用因为没有赋值



## 注意事项

1. 属性和局部变量可以重名，访问时遵循就近原则。
2. 在同一个作用域中，两个局部变量不能重名。
3. 属性生命周期较长，伴随着对象创建而创建，死亡而死亡。局部变量生命周期较短，伴随着他的代码块而创建，结束而死亡，即再一次方法调用过程中。
4. 作用域范围不同
   1. 全局变量可以被本类使用，或其他类（调用）使用
   2. 局部变量只能在本类使用。





# 构造器/构造方法 （Constructor）

**完成对新对象的初始化**



```java


[修饰符] 方法名（形参列表）{

		方法体;

}


```



1. 构造器的修饰符可以默认 也可以是 ppp
2. 没有返回值
3. 方法名和类名要一样
4. 参数列表和成员方法一样的规则
5. 构造器的调用由系统完成

## 构造器的快速入门

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 当new一个新对象时，直接通过构造器指定名字和年龄。
		Cat c = new Cat("哈基米", 18);
		Cat c2 = new Cat(31);
		System.out.println("c的信息如下：");
		System.out.println("c的名字：" + c.name);
		System.out.println("c的年龄：" + c2.age);
	}
}

class Cat {

	String name;
	int age;

	// 1. 构造器没有返回值，也不能写void
	// 2. 构造器的名称和类名Cat必须一样。
	// 3. (String cName,int cAge)是形参列表
	public Cat(String cName, int cAge) {
		System.out.println("构造器被调用，完成对象的初始化");
		name = cName;
		age = cAge;
	}

	public Cat(int cAge) {
		System.out.println("构造器被调用，完成对象Age的初始化");
		age = cAge;
	}
}
```



## 构造器的注意事项和细节

1. 一个类可以定义多个不同的构造器，即构造器的重载
   1. 创造构造器的时候只初始化人名，不初始化年龄。
2. 如果成员没有定义构造器，系统会自动给类生成一个默认无参构造器，Person(){}



练习

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 当new一个新对象时，直接通过构造器指定名字和年龄。
		Person p = new Person();// 无参构造器
		// p.name = 对象.属性
		// p.name = 对象.属性
		// p.name = 对象.属性
		System.out.println("p1的信息 name=" + p.name);
		System.out.println("p1的信息 age=" + p.age);
		Person p2 = new Person("Frank", 30);// 无参构造器
		System.out.println("p2的信息 name=" + p2.name);
		System.out.println("p2的信息 age=" + p2.age);

	}
}

class Person {
	String name;
	int age;

	public Person() {
		age = 18;
	}

	public Person(String pName, int pAge) {
		age = pAge;
		name = pName;
	}
}

```

# This关键字

哪个对象调用，this就代表哪个对象





## This 关键字使用细节



1. this关键字可以用来访问本类的属性，方法，构造器
2. this用于区分当前类的属性和局部变量
3. 访问成员方法的语法 this.方法名（参数列表）
4. 访问构造器语法 this（参数列表）（只能在构造器中使用）只能在构造器中访问另外一个构造器
5. this不能在类定义的外部使用，只能在类定义的方法中使用



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// T t1 = new T();
		// t1.f2();
		T t2;
		t2 = new T();
		T t1;
		t1 = new T();
		t1.f3();

	}
}

class T {
	String name = "jackie";

	/*
	 * Detail：
	 * 访问构造器语法 this（参数列表）（只能在构造器中使用）
	 * 只能在构造器中访问另外一个构造器
	 * Notice：
	 * 访问构造器语法：this(参数列表)
	 * 要放在第一条语句
	 */
	public T() {

		this("jack", 100);

		System.out.println("T()constructor");
		// 在这里去访问T(String name, int age)、
	}

	public T(String name, int age) {
		System.out.println("T(String name, int age)constructor");
	}

	// 访问成员方法的语法 this.方法名（参数列表）
	public void f1() {
		System.out.println("f1() method...");
	}

	public void f2() {
		System.out.println("f2() method...");
		// 调用本类的f1方法
		// 第一种方式
		f1();
		// 第二种方式
		this.f1();
	}

	public void f3() {
		String name = "Smith";
		// name就近原则，this.name准确定位到属性
		System.out.println("name: " + name);
		System.out.println("this.name: " + this.name);
	}
}
```





# 练习



### 比较两个人是否相同

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Person p1 = new Person("Mary", 20);
		Person p2 = new Person("Smith", 36);
		System.out.println(p1.compareTo(p2));
	}
}

class Person {
	String name;
	int age;

	// 这里错过，构造器必须和类名相同
	public Person(String name, int age) {
		this.name = name;
		this.age = age;
	}

	public boolean compareTo(Person p) {

		return this.name.equals(p.name) && this.age == p.age;
	}

}
```



### 编写类A01，定义方法max，实现求某个double数组的最大值，并返回

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		/*
		 * 编写类A01，定义方法max，实现求某个double数组的最大值，并返回
		 * 1.class A01
		 * 2.public double max(double[]){}
		 * 3.return double;
		 * 新建对象m1,sout中调用m1.max;
		 */
		A01 m1 = new A01();
		double arr[] = { 1, 3, 5, 4, 944, 496, 4, 54 };
		Double res = m1.max(arr);
		if (res != null) {
			System.out.println("Max of arr = " + res);

		} else {
			System.out.println("Error");
		}
	}
}

class A01 {
	public Double max(double[] arr) {

		if (arr != null && arr.length > 0) {
			double max = arr[0];
			for (int i = 1; i < arr.length; i++) {
				if (max < arr.length) {
					max = arr[i];
				}
			}
			return max;
		} else {
			return null;
		}

	}
}
```

### 编写类A02，定义方法find，实现查找某字符串数组中的元素查找，并返回索引如果找不到，返回-1

```java

public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		/*
		 * 编写类A02 定义方法find，
		 * 实现查找某字符串是否在数组中，并返回索引，
		 * 如果没有则返回-1
		 * equals(),
		 * for循环
		 * return .../-1;
		 */
		A02 finder = new A02();
		String arr[] = { "apple", "banana", "grape", };
		int index = finder.find(arr, "banana");
		System.out.println(index);
	}
}

class A02 {

	public int find(String[] arr, String fruit) {

		// 遍历
		for (int i = 0; i < arr.length; i++) {
			if (fruit.equals(arr[i])) {
				return i;
			}
		}
		return -1;
	}

}
```



### 编写类Book，定义方法updatePrice，实现更改某本书的价格，具体:如果价格>150,则更改为150，如果价格>100,更改为100，否则不变

创建对象book

用构造器初始化book的两个属性name，price

然后用updatePrice方法，进行更改价格

最后用info输出，验证结果

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 编写类Book，定义方法updatePrice，实现更改某本书的价格，
		// 具体:如果价格>150,则更改为150，如果价格>100,更改为100，
		// 否则不变
		// 提供一个构造器
		Book book = new Book("西游记", 20);
		book.info();
		book.updatePrice();// 更新价格
		book.info();
	}
}

class Book {
	double price;
	String name;

	public Book(String name, double price) {
		this.name = name;
		this.price = price;
	}

	public void updatePrice() {

		if (this.price >= 150) {
			this.price = 150;
		} else if (this.price > 100) {
			this.price = 100;
		}
	}

	public void info() {
		System.out.println("书名：" + this.name + "价格：" + this.price);
	}
}
```



### 编写类A03,实现数组的复制功能copyArr，输入旧数组，返回一个新数组，元素和旧数组一样

int一个旧数组arr1

定义A03类，创建copyArr方法，方法类型为int[] 数组的int类型

copyArr方法使用创建一个新数组，长度为arrOld.length

for循环遍历旧数组，并将旧数组的每一个元素赋值到新数组的每一个位置

即arrNew[i]=arrOld[i]

返回arrNew数组

新建copy对象

创建一个newArr数组，newArr数组等于

调用copy.copyArr方法

遍历arrNew进行验证。

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");
		/*
		 * 思路
		 * 输入一个旧数组
		 * 注意复制，因为数组是引用类型，所以需要遍历一边数组
		 * 把旧数组的内容遍历到新数组，即arrNew[i]=arrOld[i]
		 */
		int arr1[] = { 1, 3, 5, 9 };
		A03 copy = new A03();
		int[] newArr = copy.copyArr(arr1);

		// 遍历arrNew进行验证
		for (int i = 0; i < newArr.length; i++) {

			System.out.print(" " + newArr[i]);
		}
	}
}

class A03 {

	public int[] copyArr(int arrOld[]) {
		// 在堆中创建一个长度为arrOld.length的arrNew
		int[] arrNew = new int[arrOld.length];
		// 用for循环实现arrNew复制arrOld数组中的每一个元素i
		for (int i = 0; i < arrOld.length; i++) {
			arrNew[i] = arrOld[i];
		}
		return arrNew;
	}

}
```



### 定义一个圆类Circle,定义属性:半径，提供显示圆周长功能的方法，提供显示圆面积的方法

调用Math.PI

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Circle a = new Circle(3);
		System.out.println("圆a的面积为：" + a.area());
		System.out.println("圆a的周长为：" + a.length());
	}
}

class Circle {

	double radius;

	public Circle(double radius) {
		this.radius = radius;
	}

	public double area() {// 面积
		return Math.PI * radius * radius;
	}

	public double length() {// 周长
		return Math.PI * radius * 2;
	}
}
```

### 编程创建一个Cale计算类，在其中定义2个变量表示两个操作数，定义四个方法实现求和、差、乘、商(要求除数为0的话，要提示)并创建两个对象，分别测试

单独讨论商

0不能作为除数

所以以往的double类型要有一个单独提示

即，用Double封装，可以返回null值，用null值做判断

```java

public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 编程创建一个Cale计算类，在其中定义2个变量表示两个操作数，
		// 定义四个方法实现求和、差、乘、商(要求除数为0的话，要提示)

		Cale cal1 = new Cale(3, 0);
		System.out.println("1和=" + cal1.plus());
		System.out.println("1差=" + cal1.minus());
		System.out.println("1乘=" + cal1.multiply());

		if (cal1.divide() == null) {
			System.out.println("1被除数不能为0");
		} else {
			System.out.println("1商=" + cal1.divide());
		}

	}
}

class Cale {
	// 定义两个操作数
	double num1;
	double num2;

	// 构造器初始化对象
	public Cale(double num1, double num2) {
		this.num1 = num1;
		this.num2 = num2;
	}

	// 和
	public double plus() {
		return this.num1 + this.num2;
	}

	// 差
	public double minus() {
		return this.num1 - this.num2;
	}

	// 乘
	public double multiply() {
		return num1 * num2;
	}

	// 商(除数为0的话，要提示)
	public Double divide() {
		if (this.num2 == 0) {
			return null;
		}
		return this.num1 / this.num2;
	}

}
```



### 设计一个Dog类，有名字、颜色和年龄属性，定义输出方法show()显示其信息。并创建对象，进行测试、【提示 this.属性 】



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 设计一个Dog类，有名字、颜色和年龄属性，
		// 定义输出方法show()显示其信息
		// 创建对象，进行测试
		Dog dog1 = new Dog("李文超大将军", '黄', 7);
		dog1.show();
	}
}

// 定义一个dog类
class Dog {
	// 创建属性
	String name;
	char color;
	int age;

	// 创建构造器初始化对象
	public Dog(String name, char color, int age) {
		this.name = name;
		this.color = color;
		this.age = age;
	}

	// 定义方法show()
	public void show() {
		System.out.println("此狗的信息为：");
		System.out.println("名字：" + this.name);
		System.out.println("花色：" + this.color);
		System.out.println("年龄：" + this.age);
	}

}
```

### 公有类8：匿名对象，匿名对象只能用一次：new test1().count1()

![9f43becfe97dacc37683e73a48e08c98](D:\Typora\TyporaPics\9f43becfe97dacc37683e73a48e08c98.png)

![image-20251103134402030](D:\Typora\TyporaPics\image-20251103134402030.png)

### 9.定义Music类，里面有音乐名name、音乐时长times属性，并有播放play功能和返回本身属性信息的功能方法

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		// 定义Music类，
		// 里面有音乐名name、音乐时长times属性，
		// 并有播放play()功能和返回本身属性信息的功能方法getInfo()
		Music m1 = new Music("只因你太美", 2.5);
		m1.play();
		System.out.println(m1.getInfo());
	}
}

class Music {
	String name;
	double times;

	public Music(String name, double times) {
		this.name = name;
		this.times = times;
	}

	public void play() {
		System.out.println("音乐" + this.name + "正在播放中，时长" + this.times + "年");
	}

	public String getInfo() {
		return "当前播放音乐为：" + this.name + "，时长共" + this.times + "年";
	}
}
```

### 10.![image-20251103135634621](D:\Typora\TyporaPics\image-20251103135634621.png)

### 11.![image-20251103140350645](D:\Typora\TyporaPics\image-20251103140350645.png)

### 12 复用构造器:创建一个Employee类，属性有(名字，性别，年龄，职位，薪水)，提供3个构造方法，可以初始化(1)(名字，性别，年龄，职位，薪水)，(2)(名字，性别，年龄)(3)(职位，薪水)，要求充分

```java

public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		/*
		 * 创建一个Employee类，属性有(名字，性别，年龄，职位，薪水)
		 * 提供3个构造方法，可以初始化
		 * (1)(名字，性别，年龄，职位，薪水)，
		 * (2)(名字，性别，年龄)
		 * (3)(职位，薪水)，
		 * 要求充分复用构造器
		 */
		Employee e1 = new Employee("蔡徐坤", '男', 20, "Singer", 1000000);
		Employee e2 = new Employee("蔡徐坤", '男', 20);
		Employee e3 = new Employee("Singer", 1000000);
	}
}

class Employee {
	String name;
	char gender;
	int age;
	String job;
	double salary;

	public Employee(String job, double salary) {
		this.job = job;
		this.salary = salary;
	}

	public Employee(String name, char gender, int age) {
		this.name = name;
		this.gender = gender;
		this.age = age;
	}

	public Employee(String name, char gender, int age, String job, double salary) {
		this(name, gender, age);
		this.job = job;
		this.salary = salary;
	}
}
```

### 13 定义一个 Circle 类，包含一个 double 型的 radius 属性代表圆的半径，findArea() 方法返回圆的面积。定义一个类 PassObject，在类中定义一个方法 printAreas()，该方法的定义如下：public void printAreas(Circle c, int times)在 printAreas 方法中打印输出 1 到 times 之间的每个整数半径值，以及对应的面积。例如，times 为 5，则输出半径 1，2，3，4，5，以及对应的圆面积。在 main 方法中调用 printAreas() 方法，调用完毕后输出当前半径值。

输出结果为![image-20251103141826376](D:\Typora\TyporaPics\image-20251103141826376.png)

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Circle c1 = new Circle();
		PassObject p1 = new PassObject();

		p1.printAreas(c1, 5);

	}
}

// 定义一个 Circle 类，包含一个 double 型的 radius 属性代表圆的半径，
// findArea() 方法返回圆的面积。
class Circle {
	double radius;

	public Circle() {

	}

	public double findArea() {
		return Math.PI * this.radius * this.radius;
	}

	public void setRadius(double radius) {
		this.radius = radius;
	}
}

/*
 * 定义一个类 PassObject，在类中定义一个方法 printAreas()，
 * 该方法的定义如下：public void printAreas(Circle c, int times)
 * 在 printAreas 方法中打印输出 1 到 times 之间的每个整数半径值，
 * 以及对应的面积。
 * 例如，times 为 5，则输出半径 1，2，3，4，5，以及对应的圆面积。
 * 在 main 方法中调用 printAreas() 方法，调用完毕后输出当前半径值。
 */
class PassObject {
	/* 创建了一个Circle类中的c对象 */
	public void printAreas(Circle c, int times) {
		// 调用c对象

		System.out.println("Radius" + "\t" + "Areas");
		for (int i = 1; i <= times; i++) {
			// findArea的返回值就是Areas，其变量为radius
			c.setRadius(i);
			System.out.println((double) i + "\t" + c.findArea());

		}
	}
}
```

### 14 MoraGame猜拳游戏

思路

​    // Tom设计他的成员变量，成员方法，可以和电脑猜拳，电脑每次都会随机生成012,石头剪刀布，并要可以显示，tom的输赢次数。列一个清单

Tom猜拳，Scanner

Com猜拳，Random

compare判断输赢

count计数

```java
import java.util.Random;
import java.util.Scanner;

public class MainNew {
	public static void main(String[] args) {
		// 换行符
		System.out.println(" ");
		System.out.println(" ");

		int gameCount = 1;// 定义游戏局数，
		Random random = new Random();// 定义随机数random
		Scanner scanner = new Scanner(System.in);// 定义tom扫描器

		System.out.println("moraGame：");// 程序启动

		Scanner ifContinue = new Scanner(System.in);// 定义一个string扫描器
		Tom g1 = new Tom();// 输入参数

		while (true) {// 开始循环
			// 游戏开始
			System.out.println("新的回合开始了。");
			System.out.println("输入对应的数字和电脑进行猜拳：");
			System.out.println("石头：0\t剪刀：1\t布：2");

			int input = scanner.nextInt();// 等待用户输入

			if (input == 0 || input == 1 || input == 2) {// 判断输入数字是否有效

				if (input == 0) {// 翻译用户输入数字
					System.out.println("你出了石头");
				} else if (input == 1) {
					System.out.println("你出了剪刀");
				} else if (input == 2) {
					System.out.println("你出了布");
				}

				int comRan = random.nextInt(3);// 电脑随机数

				if (comRan == 0) {// 翻译电脑随机数
					System.out.println("电脑出了石头");
				} else if (comRan == 1) {
					System.out.println("电脑出了剪刀");
				} else if (comRan == 2) {
					System.out.println("电脑出了布");
				}

				g1.mora(input, comRan);// 运行游戏mora逻辑

				System.out.println("按Y继续游戏，或任意键结束");// 是否继续
				String ifContinuer = ifContinue.nextLine();// 输入参数

				if (ifContinuer.equals("Y")) {// 检查Y，
					gameCount++;// 成功的话gameCount对局数加1
					continue;// 继续循环程序。

				} else {// 结束，统计tom输赢次数
					System.out.println("游戏结束");
					System.out.println("一共游戏次数：" + gameCount);
					System.out.println("Tom赢得游戏次数为：" + g1.getWinCount());
					break;
				}

			} else {// 输入错误，关闭程序
				System.out.println("输入有误，moraGame终止。");
				break;
			}

		}
		// 关闭扫描器
		scanner.close();
		ifContinue.close();
	}
}

class Tom {
	// 定义属性
	int tomGuess;
	int comGuess;
	int winCount;

	public Tom() { // 构造器，初始化对象

	}

	public void mora(int tomGuess, int comGuess) { // 猜拳游戏核心部分
		// 更新参数
		this.tomGuess = tomGuess;
		this.comGuess = comGuess;

		if (tomGuess == 1 && comGuess == 0) { // 运行猜拳，条件，其中winCount用于增加游戏局数
			System.out.println("Win");
			winCount++;
		} else if (tomGuess == 2 && comGuess == 1) {
			System.out.println("Win");
			winCount++;
		} else if (tomGuess == 0 && comGuess == 2) {
			System.out.println("Win");
			winCount++;
		} else if (tomGuess == comGuess) {
			System.out.println("Draw");
		} else {
			System.out.println("Lose");
		}
	}

	public int getWinCount() { // 获取胜利数
		return winCount;
	}
}
```

