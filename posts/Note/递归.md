---
title: 递归
date: 2025-10-30
series: Java
category: Note
---



# 递归 



**方法递归调用**
**递归重要规则**

1. 执行一个方法时，就创建一个新的受保护的独立空间(栈空间)

2. 方法的局部变量是独立的，不会相互影响，比如n变量
3. 如果方法中使用的是引用类型变量(比如数组)，就会共享该引用类型的数据。
4. **递归必须向退出递归的条件逼近，否则就是无限递归,出现`StackOverflowError`，死龟了:)**
5. 当一个方法执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当方法执行完毕或者返回时，该方法也就执行完毕。



**关键理解点**：

- `System.out.println("n="+n)`位于递归调用`test(n-1)`之后
- 这意味着**先完成所有递归调用**，然后**从最深层的递归开始逐层返回并执行打印**
- 因此打印顺序是递归返回的顺序：2（最深层）→3→4

```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");

		T t = new T();
		t.test(4);
	}
}

class T {

	public void test(int n) {

		if (n > 2) {
			test(n - 1);

		}
		System.out.println("n=" + n);
	}

}

```





````markdown
当`t.test(4)`被调用时：

1. **n=4**: 4>2为true，调用`test(3)`，但此时**print语句还未执行**
2. **n=3**: 3>2为true，调用`test(2)`，print语句仍未执行
3. **n=2**: 2>2为false，跳过if语句，**执行`System.out.println("n="+2)`** → 输出"2"
4. **递归返回**: 回到n=3的调用点，继续执行后面的`System.out.println("n="+3)` → 输出"3"
5. **递归返回**: 回到n=4的调用点，继续执行后面的`System.out.println("n="+4)` → 输出"4"

**关键理解点**：
- `System.out.println("n="+n)`位于递归调用`test(n-1)`之后
- 这意味着**先完成所有递归调用**，然后**从最深层的递归开始逐层返回并执行打印**
- 因此打印顺序是递归返回的顺序：2（最深层）→3→4

如果代码改为：
```java
System.out.println("n="+n);  // 先打印
if (n > 2) {
    test(n-1);  // 后递归
}
```
那么输出就会是4、3、2的顺序。
````



若将`System.out.println("n="+n);`置于if后新加的else，则只有n=2



## 阶乘



```java

public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");

		// 阶乘使用
        T t = new T();
		int res = t.factorial(5);
		System.out.println("res=" + res);

	}
}

class T {


	public int factorial(int n) {// 阶乘
		if (n == 1) {
			return 1;

		} else {
			return factorial(n - 1) * n;
		}
	}

}

```



```powershell
res=120
```



![阶乘的内存分析](D:\Typora\TyporaPics\image-20251030110838645.png)



## 斐波那契数列



**请使用递归的方式求出斐波那契数1,1,2,3,5,8,13..给你一个整数n，求出它的值**

分析：

n= 1 1+0=1

n= 2 1+0=1

n= 3 1+1=2

n= 4 1+2=3

n= 5 2+3=5

...

算法为

n=(n-2) + (n-1)







```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");

		// 使用斐波那契数列方法
		T t = new T();
		int res = t.test(5);
		System.out.println("斐波那契数列为" + res);
	}
}

class T {

	public int test(int n) { // 斐波那契数列方法

		if (n >= 1) {
			if (n == 1 || n == 2) {
				return 1;
			} else {
				return test(n - 1) + test(n - 2);
			}
		} else {

			System.out.println("要求输入n>1的数");
			return -1;
		}

		/*
		 * 分析：
		 * n= 1 1+0=1
		 * n= 2 1+1=2
		 * n= 3 1+2=3
		 * n= 4 2+3=5
		 * n= 5 3+5=8
		 * 算法为
		 * n=(n-2) + (n-1)
		 */
	}

}

```



## 猴子吃桃





```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");
		System.out.println(" ");

		T t = new T();
	//使用猴子吃桃
		int day = -1;
		int peachNum = t.peach(day);
		if (peachNum != -1) {
			System.out.println("第" + day + "天的桃子数量：" + peachNum);
		}
		System.out.println("");
	}
}

class T {

	public int peach(int day) { //猴子吃桃方法

		if (day == 10) {
			return 1;
		} else if (day >= 1 && day <= 9) {
			return (peach(day + 1) + 1) * 2;
		} else {
			System.out.println("day在1-10之间");
			return -1;
		}
		/*
		 * 分析：
		 * 猴子吃桃子问题:有一堆桃子 N，猴子第一天吃了其中的一半 M=N/2，
		 * 并再多吃了一个以后每天猴子都吃其中的一半M/2，然后再多吃一个-1。
		 * 当到第10天时，想再吃时(即还没吃)，发现只有1个桃子了。
		 * 问题:最初共多少个桃子?
		 * day 10 ,peach10 = 1
		 * day 9 , peach9 = peach10+1 * 2 = 4
		 * day 8 , peach8 = peach9+1 * 2 = 10
		 * day n , peachN = peachN+1 * 2
		 * 前一天的桃子 = （后一天的桃子+1）*2
		 * 递归
		 */

	}

}

```



## 老鼠走迷宫



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		T t = new T();

		/*
		 * 思路：
		 * 创建迷宫，用二维数组表示，int[][]map=new int[8][7]
		 * 规定map数组的元素值，0表示可以走的路，1表示障碍物。
		 */
		int[][] map = new int[8][7];
		/* 将最上面的一行，和最下面的一行，全部设置为1 */
		for (int i = 0; i < 7; i++) {
			map[0][i] = 1;
			map[7][i] = 1;

		}

		/* 将最右面的一列和最左面的一列，全部设置为1 */

		for (int i = 0; i < 8; i++) {
			map[i][0] = 1;
			map[i][6] = 1;
		}
		// 设置障碍
		map[3][1] = 1;
		map[3][2] = 1;
		map[2][2] = 1;

		// 输出当前的地图
		System.out.println("\n====当前地图情况====");
		for (int i = 0; i < map.length; i++) {
			for (int j = 0; j < map[i].length; j++) {
				System.out.print(map[i][j] + " ");// 输出一行
			}
			System.out.println();
		}

		// 使用findWay给老鼠找路
		T t1 = new T();

		t1.findWay(map, 1, 1);
		// 输出当前的地图
		System.out.println("\n====找路的情况如下====");
		for (int i = 0; i < map.length; i++) {
			for (int j = 0; j < map[i].length; j++) {
				System.out.print(map[i][j] + " ");// 输出一行
			}
			System.out.println();
		}
	}
}

class T {
	/*
	 * use 递归回溯的思想解决老鼠出迷宫
	 * map是二维数组，即表示迷宫
	 * i,j 老鼠的位置，初始化为1,1
	 * 因为是递归的找路，所以要找到退出递归路径，规定map[][]各个值的含义
	 * 0表示可以走1表示障碍物，2可以走，3表示走过，但是是死路，
	 * 当map[6][5]=2表示找到通路，就可以结束递归，否则继续找
	 * 先确定老鼠找路的策略，⬇️➡️⬆️⬅️
	 */
	// 找出迷宫出口的路径findWay T找到 F没找到

	public boolean findWay(int[][] map, int i, int j) {

		if (map[6][5] == 2) {// 找到路
			return true;
		} else {
			if (map[i][j] == 0) {// 当前位置为0,说明可以走，没走过
				// 我们假定可以走通，
				map[i][j] = 2;
				// 使用找路策略开始测试，来确定该点该位置是否真的可以走通，
				if (findWay(map, i + 1, j)) {// ⬇️
					return true;
				} else if (findWay(map, i, j + 1)) {// ➡️
					return true;
				} else if (findWay(map, i - 1, j)) {// ⬆️
					return true;
				} else if (findWay(map, i, j - 1)) {// ⬅️
					return true;
				} else {
					map[i][j] = 3;
					return false;
				}
			} else {// map[i][j]=1 or = 2 or = 3
				return false;
			}
		}
	}

	public boolean findWay2(int[][] map, int i, int j) {

		if (map[6][5] == 2) {// 找到路
			return true;
		} else {
			if (map[i][j] == 0) {// 当前位置为0,说明可以走，没走过
				// 我们假定可以走通，
				map[i][j] = 2;
				// 使用找路策略开始测试，来确定该点该位置是否真的可以走通，
				if (findWay2(map, i, j + 1)) {
					return true;
				} else if (findWay2(map, i + 1, j)) {
					return true;
				} else if (findWay2(map, i, j - 1)) {
					return true;
				} else if (findWay2(map, i - 1, j)) {
					return true;
				} else {
					map[i][j] = 3;
					return false;
				}
			} else {// map[i][j]=1 or = 2 or = 3
				return false;
			}
		}
	}

}

```





## 汉诺塔



```java
public class MainNew {
	public static void main(String[] args) {
		System.out.println(" ");
		System.out.println(" ");

		Tower tower = new Tower();

		tower.move(3, 'A', 'B', 'C');

	}
}

class Tower {

	public void move(int num, char a, char b, char c) {
		// 如果只有一个盘num=1
		if (num == 1) {
			System.out.println(a + "->" + c);

		} else {
			// 如果有多个盘，可以看成两个，最下面的和最上面的所有盘
			// 1. 先移动上面所有的盘到b，借助c
			move(num - 1, a, c, b);
			// 2. 把最下面的这个盘，移动到C
			System.out.println(a + "->" + c);
			// 3. 再把b塔的所有盘，移动到c，借助a
			move(num - 1, b, a, c);
		}
	}
}

```

